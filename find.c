/******************************************************** Intranet  version 2.0  Programmet visar alla titlar som stämmer överens med author.cgi?method=select&author=xxxxx  Program: %I% Version:  %M% Date:	%D%  written by Casimir Artmann. Copyright Casimir Artmann. 1996-1998.*********************************************************/#include <stdio.h>#include <stdlib.h>#include <string.h>#include <time.h>#define TRUE 1#define FALSE 0   /* funktioner fˆr hantering av cgi-anrop och felhantering */#include "../cgi.h"  #include "../utils.h"  /* gemensamma funktioner fˆr konferanssystemet */#include "intra.h"#include "db.h"  #include "html.h"  /* fˆljande funktioner anropas  */int ExpandAuthor ( struct _CGIarg *CGIarg,  int *category_id, int *subject_id, char *author ) ;      /* huvudprogram find */main ( int argc, char *argv[] ){char path[255] ;int method ;int counter ;char *instring ;             /* inl‰st teckenstr‰ng frÂn formul‰r */struct _CGI CGI ;            /* CGI environment */struct _CGIarg CGIarg ;      /* lista med varibelnamn och v‰rden frÂn formul‰r*/struct _user user ;          /* data fˆr en anv‰ndare */ struct _title *title ;  char author[255] ;char sort[255] ;char cursor[255] ;int category_id ;int subject_id ;/* l‰s in CGI environment */strcpy ( path, argv[0] ) ;InitIntra ( path) ;InitCGI () ;GetCGI ( &instring, &CGI ) ;     /* konvertera v‰rden frÂn formul‰r */bURLencode ( instring, &CGIarg ) ;ExpandMethod ( &CGIarg, &method ) ;    ExpandFind ( &CGIarg, &category_id, &subject_id, author, company ) ;findUser ( CGI.remote_user, &user ) ;  /* visa rubriker */if ( method == SELECT )  {                     							   catHTML ( HEADER ) ;           /* skriv ut ett sidhuvud i HTML     */     /* exit if not using frames */   if ( !FRAMES )     exit(0) ;	    /* read new titles */   title = malloc ( sizeof ( struct _title )) ;    counter = SelectAuthor ( user, title, author, sort, cursor ) ;      /* print a list of all titles within one subject */        printTitleHTML ( category_id, subject_id, user, title ) ; /* skriv ut rubriker som HTML-kod    */   /* free ( title ) ; */      catHTML ( FOOTER ) ;           /* skriv ut en sidfot i HTML        */  }return ( TRUE ) ;                    }  /* end of main () */int ExpandFind ( struct _CGIarg *CGIarg,  int *category_id, int *subject_id, char *author, char*company )   /*       Funktionen ˆvers‰tter argument frÂn CGI-script till en post i en l‰nkad lista            Om inga fel intr‰ffar returneras TRUE      Om v‰rde ˆverskrider min eller maxv‰rde sÂ returnerar funktionen FALSE      Om nÂgon annan typ av fel intr‰ffar sÂ returneras ERROR            CGIarg innhÂller en l‰nkad lista med variabelnamn och v‰rden            Om v‰rden saknas s‰tts NULL           Fˆljande argument anv‰nds av funktionen      */{struct _CGIarg *first ;int size ;first = malloc ( sizeof ( *CGIarg )) ;first = CGIarg ;*category_id = -1 ;*subject_id = -1 ; while ( CGIarg != NULL )  {     size = strlen ( CGIarg->value ) ;    /* id of conferance */  if ( !strncmp("category", CGIarg->name, 8 ))    *category_id = atoi ( CGIarg->value ) ;  if ( !strncmp("subject", CGIarg->name, 7 ))    *subject_id = atoi ( CGIarg->value ) ;   if ( !strncmp("author", CGIarg->name, 6 )) {    strncpy( author, CGIarg->value,255 ) ;   author[size] = (char) NULL ;       if ( !strncmp("company", CGIarg->name, 7 )) {    company( author, CGIarg->value,255 ) ;   company[size] = (char) NULL ;   }  CGIarg = CGIarg->next ; }CGIarg = first ;/*free ( first ) ;*/return ( TRUE ) ;}SelectAuthor ( struct _user user, struct _title *title, char *author, char *sort, char *cursor )   /* subject - l‰nkad lista med aktuella rubriker      show    - UNREAD, visa alla inl‰gg      sort    - DATE, sortera efter datum      cursor  - NULL            */{int category_id ;               /* r‰knare fˆr str‰ngar */int subject_id ; int counter ;           /* antal l‰sta poster */int groups ;            /* vilken nyhetsgrupp som avses */int categories ;        /* vilka rubriker som finns */char filename[128] ;    /* filnamn fˆr fil som innehÂller ett inl‰gg */char string[255];       /* rad fˆr rubrik */char sName[40] ;int skip ;                 /* hoppa ˆver posten */               FILE *fp, *lock ;struct _title cur_title ;    /* inl‰st post */struct _title *first_title ;struct _title *new_title ;struct _title *ptr_title ;filename[0] = (char) NULL ;skip = FALSE ;counter = 0 ;title->next = NULL ;first_title = title ;         /* l‰s antal katagorier */    categories = getLastCategoryId () ;  for (category_id=1;category_id<=categories;category_id++)   /* fˆr varje katagori */   {     /* l‰s antal ‰mnen fˆr aktuell kategori */    groups = getLastSubjectId ( category_id ) ;    if ( groups == 0 )     continue ;    for (subject_id=1;subject_id<=groups;subject_id++)     {          /* Om valt ‰mne saknas skall man hoppa ˆver detta ‰mne */      if ( !getSubjectName ( category_id,subject_id,sName ))        continue ;        /* s‰tt v‰rden fˆr aktuell kategori / ‰mne */  /* Om lÂsfilen inte gÂr att ˆppna skall man inte forts‰tta */if ( strcmp( EDITION, "Limited"))  sprintf( filename, "%s/news-%d-%d.lck", DB_PATH, category_id, subject_id ) ; else  sprintf( filename, "%s/news-%d.lck", DB_PATH, subject_id ) ; if (( lock = fopen ( filename, "w" )) == NULL )   {    sprintf ( string, "Rubriker %s kan ej l‰sas.", filename ) ;    errorHTML ( string ) ;    return ( -1 ) ;   }    /* ˆppna filen fˆr l‰sning */if ( strcmp( EDITION, "Limited"))  sprintf( filename, "%s/news-%d-%d.dat", DB_PATH, category_id, subject_id ) ; else  sprintf( filename, "%s/news-%d.dat", DB_PATH, subject_id ) ; if (( fp = fopen ( filename, "r" )) == NULL )   {    sprintf ( string, "Rubriker %s kan ej l‰sas.", filename ) ;    errorHTML ( string ) ;    return ( -1 ) ;   }  /* l‰s rubriker frÂn fil */while ( fgets ( string, 255, fp ) != NULL )  {                                                  cur_title.created [0] = (char) NULL ;      readTitle ( string, &cur_title ) ;    /* Skall posten vara med ? */   skip = FALSE ;  if (strncmp ( cur_title.author, author, strlen(author)))    skip = TRUE ;	  if ( skip == FALSE  )                                /*  posten skall l‰sas  - fˆr ˆver till l‰nkad lista*/    {     if ( counter >  0)                  /* First record in list */       {        ptr_title = malloc ( sizeof ( struct _title )) ;        ptr_title->next = NULL ;                    title->next = ptr_title ;                         title = ptr_title ;       }          strcpy ( title->name, cur_title.name ) ;      strcpy ( title->email, cur_title.email ) ;      strcpy ( title->created, cur_title.created ) ;      strcpy ( title->author, cur_title.author ) ;      strcpy ( title->company, cur_title.company ) ;      strcpy ( title->href, cur_title.href ) ;      title->category = category_id ;      title->subject = subject_id ;      title->id = cur_title.id ;      title->indent = cur_title.indent ;      title->security = cur_title.security ;      title->owner = cur_title.owner ;      title->object = cur_title.object ;         title->subclass = cur_title.subclass  ;            counter ++ ;         }        /* end of skip == TRUE ; */  } /* end of while */fclose ( fp ) ;fclose ( lock ) ;    } }  /*  */title = first_title ;return ( counter ) ; } /* end of SelectAuthor */